<br><p>Il programma si basa sulle seguenti librerie:</p><ul><li>SDL 2.0 per la creazione della finestra e la gestione degli input</li><li>OpenGL per il rendering</li><li>SOIL (Simple OpenGL Image Library) per il caricamento delle texture</li><li>GLM (OpenGL Mathematics) per la parte matematica</li><li>TinyXML 2 per il parsing dei file xml</li></ul><p>Durante l'inizializzazione del programma un Builder si occupa di creare il player e la mappa, basandosi su file xml.</p><img src="../static/projects/Tile Engine C++/descriptionImages/uml c++ builder.png" style="max-width:100%;"><img src="xml file"><p>Ogni oggetto da renderizzare implementa la classe virtuale Renderable.</p><br><div  style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code>class Renderable{public:	Renderable(){}	virtual ~Renderable(){};	virtual void render()=0;	virtual void update()=0;	virtual void bindProjectionMatrix(glm::mat4 projectionMatrix)=0;};</code></pre></div><br><p>Ogni oggetto Renderable viene inserito in un vector che verr√† inviato al Renderer.<br>Il Renderer al momento della creazione inizializza la projection matrix (in questo caso ortogonale) e ad ogni frame effettua il clear della finestra, poi per ogni oggetto Renderable esegue il loop di update e rendering:</p><br><div style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code>entity->update();entity->bindProjectionMatrix(projection);entity->render();</code></pre></div><br><h3>Input</h3><p>La gestione degli input &eacute; effettuata tramite un Observer</p><img src="../static/projects/Tile Engine C++/descriptionImages/uml c++ observer.png"  style="max-width:100%;"><p>Durante il main loop del programma viene richiamato il metodo <samp>checkInput()</samp> che attraverso il metodo <samp>SDL_PollEvent()</samp> della libreria SDL controlla tutti gli eventi avvenuti, se uno di questi corrisponde ad un evento noto (es. pressione dei tasti W, A, S, D, ESC...) viene aggiunto il tasto alla lista degli eventi e il suo stato (true/false) all'array degli stati e viene asserito il flag <samp>changed</samp>.<br>Alla fine del ciclo, se <samp>changed == true</samp> vengono notificati gli Observers e gli viene passata la lista degli eventi che viene poi azzerata.</p><br><h3>Entity</h3><p>Gli oggetti di gioco implementano la classe virtuale Entity:</p><div  style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code>class Entity: public Renderable{public:	Entity(){};	virtual ~Entity(){};	virtual void setTile(Tile* tile)=0;	virtual void setTileset(std::vector<Tileset*> tileset)=0;	virtual void setTexture(Texture* texture)=0;	virtual void setAnimation(Animation* animation)=0;	virtual void setShader(Shader* shader)=0;	virtual void bindBuffers()=0;};</code></pre></div><img src="../static/projects/Tile Engine C++/descriptionImages/uml c++ entity composition.png"  style="max-width:100%;"><p>La Tile rappresenta il modello 3d da renderizzare (in questo caso un quadrato 128x128 pixel), contiene infatti gli array di vertici e indici del modello e la model matrix, con i relativi metodi per ruotare, scalare e spostare il modello.<br>I Tileset rappresentano i differenti set di texture del modello </p><img src="../static/projects/Tile Engine C++/descriptionImages/Player.jpg"  style="max-width:100%;"><p>contengono tutti gli attributi della texture e l'oggetto Texture.<br>Le Animations sono le differenti animazioni effettuabili dal modello attraverso il cambio della texture sul tileset.<br>L'oggetto shader contiene l'id dello shader program caricato in memoria e i metodi per passargli gli attributes e gli uniforms necessari al rendering.<br>Il metodo <samp>bindBuffers()</samp> crea e carica sulla memoria video i buffer per i modelli da renderizzare.<br><h3>TileMap</h3><br>L'oggetto TileMap oltre ad avere tutti i componenti di una Entity &eacute; formata anche da un vector di TileLevel, che contiene tutti i livelli di una mappa (es. mare, terra, edifici...).<br>Ogni TileLevel &eacute; composta da un TileSet, da un vector di vettori tridimensionali contenenti le posizioni di ogni tile e un vector contenente l'id di ogni tile, necessario per applicare la giusta texture al modello.<br>Il rendering della TileMap, a differenza di quello delle Entity, viene effettuato tramite il metodo <samp>glDrawElementsInstanced()</samp> delle OpenGL, in modo da renderizzare le tile della mappa con un unica draw call, per questo motivo gli id delle tile vengono caricati nella memoria video come Shader Storage Buffer Object, a cui si accede negli shader tramite l'attributo <samp>gl_InstanceID</samp>.</p>