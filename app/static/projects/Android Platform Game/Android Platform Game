<p>Il programma &eacute; un semplice gioco platform per android, scritto in java utilizzando le librerie OpenGL ES 3.0</p><p>All'avvio viene creata l'Activity principale, dove vengono impostati i parametri di visualizzazione dell'app, come la visualizzazione in modalita landscape, il layout full screen e la scomparsa della barra di navigazione.<br>A questo punto viene creata una GLSurfaceView, ovvero la superficie dove verra renderizzato il gioco.<br>La classe GLSurfaceView contiene il metodo <samp>onTouchEvent()</samp>, che viene richiamato ogni volta che avviene un evento di tipo touch.<br><samp>onTouchEvent()</samp> a sua volta chiama il metodo <samp>checkInput</samp> della classe Input, e gli invia l'evento e la lista dei Button richiesta alla classe GLRenderer.<br>Il metodo <samp>checkInput</samp> si occupa di verificare se un tocco &eacute; avvenuto in una posizione occupata da un Button, e il tipo di evento (pressione o rilascio), in caso affermativo viene modificato il corrispondente attributo nella mappa keys, che collega ad ogni Button il suo stato.<br>Durante la creazione viene impostata la versione minima richiesta per le OpenGL ES, <samp>setEGLContextClientVersion(3)</samp>, viene poi creato un Renderer e impostato come renderer corrente.<br>La classe GLRenderer implementa l'interfaccia GLSurfaceView.Renderer e i suoi metodi <samp>onSurfaceCreated()</samp>, <samp>onSurfaceChanged()</samp> e <samp>onDrawFrame()</samp>.<br><samp>onSurfaceCreated()</samp> viene invocato alla creazione della superficie di rendering e contiene la sezione di inizializzazione del gioco.<br><samp>onSurfaceChanged()</samp> viene chiamato dopo la creazione e ad ogni cambiamento della superficie, ad esempio quando si passa dalla modalita portrait a quella landscape, al suo interno contiene le chiamate ai metodi per impostare la dimensione della viewport e per cambiare la matrice di proiezione, che deve essere modificata in base all'orientamento del display.<br><samp>onDrawFrame()</samp> viene chiamato ogni volta che un nuovo frame deve essere renderizzato.</p><p>La classe GLRenderer &eacute; composta da un oggetto Render, che contiene i metodi pe il rendering degli oggetti di gioco, un oggetto Physics, che si occupa di gestire la fisica, un oggetto Camera, che gestisce la posizione della vista, e tre liste, una contenente i Buttons della UI per gli input, una che contiene le Entity che sono soggette alla fisica e che verranno inviate al motore fisico, e una lista di oggetti Renderable che verranno inviati al Renderer per essere disegnati a schermo.</p><h2>Inizializzazione</h2><p>Durante l'inizializzazione un Builder si occupa di creare la TileMap, il Player e i Button.</p><div style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code> public void onSurfaceCreated(GL10 gl, EGLConfig config) {    TileMapCreationDirector mapDirector = new TileMapCreationDirector();    mapDirector.setMapBuilder(new TileMapBuilder());    mapDirector.createEntity();    renderables.add(mapDirector.getEntity());    EntityCreationDirector director = new EntityCreationDirector();    director.setEntityBuilder(new PlayerBuilder());    director.createEntity();    renderables.add(director.getEntity());    physical.add(director.getEntity());    director.setEntityBuilder(new ButtonBuilder(Util.BUTTON_LEFT));    director.createEntity();    renderables.add(director.getEntity());    director.setEntityBuilder(new ButtonBuilder(Util.BUTTON_RIGHT));    director.createEntity();    renderables.add(director.getEntity());    director.setEntityBuilder(new ButtonBuilder(Util.BUTTON_UP));    director.createEntity();    renderables.add(director.getEntity());}</code></pre></div><img src="../static/projects/Android Platform Game/descriptionImages/umlJavaBuilder.jpg" style="max-width:100%;"><p>Le classi Player e Button derivano dalla classe astratta Entity, che implementa Renderable perche ogni Entity deve poter essere renderizzata.<br>Nella classe ENtity sono definiti i metodi per la costruzione di un entita nel gioco.</p><div style="border-style: solid;padding: 10px;border-width: thin;max-width:100%;overflow:scroll;"><pre><code>public abstract class Entity implements Renderable{    public abstract void setTile(Tile tile);    public abstract void setTileset(List&lt;Tileset&gt; tileset);    public abstract void setAnimation(List&lt;Animation&gt; animations);    public abstract void setShader(Shader shader);    public abstract void bindBuffers();}</code></pre></div><p>Ogni Entity &eacute; formata da:</p><ul><li><p>Una Tile, che rappresenta il modello 3d e contiene gli array di vertici e indici per il disegno, la model matrix e i metodi per spostare, ruotare e scalare l'oggetto.</p></li><li><p>Una lista di Tileset, ognuno dei quali rappresenta l'insieme di texture di un entity</p><img src="../static/projects/Android Platform Game/descriptionImages/image4.jpg" style="max-width:100%;"><p>al suo interno contiene infatti la Texture e tutti gli attributi che la descrivono. Contiene inoltre una Java Map di BoundingBox per la gestione delle collisioni.</p></li><li><p>Una lista di Animation, che a seconda dei casi vengono gestite direttamente dalla Entity (Button), oppure da delle classi apposite (Player)</p></li><li><p>Un oggetto Shader.<br>La classe astratta Shader contiene l'ID dello shader program, i metodi per crearlo dai file degli shader e quelli per avviarlo e chiuderlo, oltre ai metodi per caricare i vari uniform sulla memoria video.</p><div style="border-style: solid;padding: 10px;border-width: thin;max-width:100%;overflow:scroll;"><pre><code>protected void loadVector3f(int location, Vector3f vector){    GLES20.glUniform3f(location, vector.x, vector.y, vector.z);}</code></pre></div><p>Ogni Entity ha poi una sua classe derivata da Shader in cui vengono definite le posizioni nel file System degli shader file, dove vengono salvate le posizioni in memoria degli uniform e dove vengono definiti i metodi per assegnargli dei valori</p><div style="border-style: solid;padding: 10px;border-width: thin;max-width:100%;overflow:scroll;"><pre><code>public void loadModelMatrix(float[] matrix){    super.loadMatrix(location_modelMatrix, matrix);}</code></pre></div></li></ul><p>La TileMap a differenza del Player e dei Button implementa direttamente l'interfaccia Renderable, poiche la mappa &eacute; composta da piu tile e piu livelli.<br>La TileMap &eacute; formata da una lista di Tileset e da uno Shader come le Entity, in piu ha una lista di TileLevel, che rappresentano i vari livelli da renderizzare della mappa (Oggetti in primo piano, sullo sfondo, terreno, ecc...).<br>Ogni TileLevel contiene un array con le posizioni di ogni tile del livello e una lista di ID che rappresentano la texture da applicare ad ogni tile.</p><img src="../static/projects/Android Platform Game/descriptionImages/image5.jpg" style="max-width:100%;"><p>Una volta creati tutti gli oggetti si passa alla creazione della Camera.<br>La classe Camera contiene la view matrix e tutti i metodi e gli attributi per modificarla e quindi modificare la vista corrente.<br>Dopo la Camera viene instanziato il Renderer, che come prima cosa crea la matrice di proiezione ortogonale.<br>La classe Renderer contiene il metodo <samp>render(List&lt;Renderable&gt;)</samp> a cui viene passata la lista di Renderable da renderizzare.<br>Il rendering vero e proprio viene effettuato in modo differente da ogni Renderable, il metodo <samp>render()</samp> si occupa solo di chiamare i metodi di update, di inviare le matrici di proiezione e vista e di invocare il metodo render per ogni Renderable.</p><div style="border-style: solid;padding: 10px;border-width: thin;max-width:100%;overflow:scroll;"><pre><code>public void render(List&lt;Renderable&gt; renderables, Camera camera){    for(Renderable renderable : renderables){        renderable.update();        renderable.bindProjectionMatrix(projectionMatrix);        renderable.bindViewMatrix(camera.getViewMatrix());        renderable.render();    }}</code></pre></div><p>Per ultimo viene avviato il DisplayManager che si occupa del timer del programma.</p><h2>onDrawFrame()</h2><p>Il loop principale del programma &eacute; rappresentato dal metodo onDrawFrame, che viene richiamato ciclicamente.<br>Ad ogni nuovo frame viene invocato il metodo <samp>update()</samp> del DisplayManager che calcola il tempo trascorso dall'ultimo frame.<br>A questo punto la Camera viene spostata in modo da avere il Player sempre al centro del display.<br>Modificata la camera si passa al ciclo che chiama il metodo <samp>handleInput</samp> per ogni Renderable, questo metodo ha un comportamento differente a seconda dell'oggetto su cui &eacute; invocato, nel Player si occupa di aggiornare lo stato corrente.<br>Lo sttao del Player &eacute; gestito dal pattern State</p><img src="../static/projects/Android Platform Game/descriptionImages/umlJavaState.jpg" style="max-width:100%;"><p>La classe astratta PlayerState contiene i riferimenti a tutti gli stati e le animazioni del Player, e le definizioni dei metodi per la loro gestione, <samp>start()</samp>, <samp>stop()</samp>, <samp>update()</samp> e <samp>exit()</samp>.<br>Ogni State gestisce poi in maniera autonoma il suo comportamento.<br>Quando viene richiamato il metodo <samp>handleInput</samp> del Player, viene invocato a sua volta il metodo <samp>handleInput</samp> sullo stato corrente, questo controlla lo stato degli input e ritorna l'oggetto State opportuno</p><div style="border-style: solid;padding: 10px;border-width: thin;max-width:100%;overflow:scroll;"><pre><code>public PlayerState handleInput(Player player) {    if(Input.isKeyDown(Util.BUTTON_RIGHT)){        buttonRightPressed = true;    }else if(Input.isKeyUp(Util.BUTTON_RIGHT)){        buttonRightPressed = false;    }    if(Input.isKeyUp(Util.BUTTON_RIGHT) <br>	&& Input.isKeyUp(Util.BUTTON_LEFT) <br>	&& Input.isKeyUp(Util.BUTTON_UP)){        exit();        return idleRightState;    }    if(Input.isKeyUp(Util.BUTTON_UP)){        exit();        return idleRightState;    }    if(!player.isJumping()){        exit();        return idleRightState;    }    return null;}</code></pre></div><p>A questo punto nel Player se lo stato corrente &eacute; cambiato viene invocato il metodo <samp>enter()</samp> del nuovo stato, che si occupa di avviare la giusta animazione e di inizializzare lo stato</p><div style="border-style: solid;padding: 10px;border-width: thin;max-width:100%;overflow:scroll;"><pre><code>public void enter(Player player) {    player.setJumping(true);    jumpStartTime = DisplayManager.getCurrentTime();    jumpingRightAnimation.start(DisplayManager.getCurrentTime());}</code></pre></div><p>Prima di chiamare il metodo <samp>render()</samp> il Renderer invoca il metodo <samp>update()</samp> sui Renderable, che, nel Player, invoca il metodo <samp>update()</samp> dello stato corrente, che si occupa di aggiornare lo stato e di muovere il Player se necessario.</p><p>Finita la gestione degli input viene chiamato il metodo <samp>update()</samp> dell'oggetto Physics, a cui vengono passate le Entity da aggiornare e la TileMap</p><h4>Physics</h4><p>Il metodo <samp>update()</samp> esegue un ciclo in cui chiama il metodo <samp>applyGravity()</samp> su ogni Entity.<br>Questo controlla la posizione dell'Entity sulla mappa e richiede le BoundingBox di tutte le tile che la circondano.</p><img src="../static/projects/Android Platform Game/descriptionImages/Collision2.jpg" style="max-width:100%;"><img src="../static/projects/Android Platform Game/descriptionImages/Collision1.jpg" style="max-width:100%;"><p>A questo punto applica la gravita e calcola la posizione futura dell'Entity, se questa non provoca alcuna collisione l'entity viene spostata, altrimenti viene spostata solo dello spazio necessario a raggiungere la collisione.</p><p>Finita la gestione della fisica viene invocato il metodo <samp>render(List&lt;Renderable&gt;)</samp> del Renderer a cui vengono passati tutti gli oggetti da renderizzare e la camera.<br>Ogni oggetto ha il suo metodo per effettuare il rendering, per esempio la TileMap, a differenza degli altri oggetti, viene renderizzata invocando il metodo delle OpenGL <samp>glDrawElementsInstanced()</samp>, in modo da renderizzare tutte le tile che la compongono in una sola draw call.</p>