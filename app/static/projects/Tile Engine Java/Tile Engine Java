<p>Il programma &eacute; scritto con le librerie LWJGL 2</p><p>L'esecuzione si divide in tre parti: inizializzazione, main loop e chiusura.</p><h2>Inizializzazione</h2><p>Durante la fase di inizializzazione viene instanziato un oggetto Game che si occupa del caricamento e della creazione di tutti gli oggetti di gioco.<br>La finestra del programma viene gestita dalla classe DisplayManager che si occupa della creazione, del clear, dell'update e della chiusura.<br>Mediante un Builder vengono poi create le varie Entity e la TileMap.</p><img src="../static/projects/Tile Engine Java/descriptionImages/umlJavaBuilder.jpg"  style="max-width:100%;"><h4>Entity</h4><p>Ogni Entity implementa l'interfaccia Renderable, che contiene i metodi utilizzati dal Renderer ad ogni frame.</p><div  style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code>public interface Renderable {	void render();	void handleInput();	void update();	void bindProjectionMatrix(Matrix4f projectionMatrix);	void bindViewMatrix(Matrix4f viewMatrix);}</code></pre></div><p>La classe Entity &eacute; astratta e contiene i metodi per la creazione e la gestione di ogni entity in gioco.<br>Ogni Entity &eacute; composta da:<ul><li><p>Una Tile, che rappresenta il modello 3d, in questo caso un quadrato, le cui dimensioni vengono lette dal file xml che descrive l'oggetto.</p><div style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code>&lt;tileset name="knight" src="res/tilesets/knight_img.png"<br> width="512" height="512" tilesNumber="16" tileWidth="128" tileHeight="128"&gt;&lt;/tileset&gt;</code></pre></div><p>La Tile contiene anche la model matrix e tutti gli attributi e metodi per modificarne posizione, scala e rotazione.</p></li><li><p>Una lista di Tileset, ognuno dei quali rappresenta un set differente di texture da applicare alla Tile.</p><img src="../static/projects/Tile Engine Java/descriptionImages/knight_img.png"  style="max-width:100%;"><p>Ogni Tileset contiene anche una Map Java di BoundingBox che contiene le differenti bounding box per ogni texture nel set.</p></li><li><p>Una lista di Animation.<br>La classe astratta Animation contiene gli attributi e le dichiarazioni dei metodi comuni a tutte le animazioni, come <samp>start()</samp>, <samp>update()</samp> e <samp>stop()</samp>.<br>Ogni animazione &eacute; composta da un array di interi che contiene la successione di ID delle texture su un tileset.</p><img src="../static/projects/Tile Engine Java/descriptionImages/idAnimation.jpg"  style="max-width:100%;"><p>Ogni animazione puo implementare i metodi start, stop e update in modo differente per avere diversi tip idi animazione, per esempio cambiando la velocita di update dei frame.</p><div style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code>public class RunningRightAnimation extends Animation {	public RunningRightAnimation(int type, String animationName,<br> int animationLength, int[] frames) {	super(type, animationName, animationLength, frames);        this.frameTime = 200;    }    @Override    public void update(long time) {        if(time - startTime > frameTime){            index = (index+1)%length;            currentID = ids[index];            startTime += frameTime;        }    }    @Override    public void start(long time) {        startTime = time;        currentID = ids[0];        index = 0;    }    @Override    public void stop() {        startTime = 0;        currentID = ids[0];        index = 0;    }}</code></pre></div></li><li><p>Un oggetto Shader.<br>La classe astratta Shader contiene gli ID degli shader e del program, i metodi per avviare e chiudere il program corrente e tutti i metodi per caricare attributes e uniforms negli shader.<br>Ogni oggetto in gioco avra poi una sua classe shader derivata, contenente i file degli shader, gli ID delle posizioni in memoria degli uniform e i metodi per caricare i diversi attributi dell'oggetto</p><div  style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code>public class PlayerShader extends Shader{    public void loadTextureIndex(int textureIndex){            super.loadInt(location_textureIndex, textureIndex);        }}></code></pre></div></li></ul><h4>TileMap</h4><p>La TileMap come le Entity contiene il modello di una tile, una lista di tileset, gli shader (innquesto caso quelli per la mappa) e in piu una lista di TileLevel.<br>Ogni TileLEvel contiene un diverso livello da renderizzare, ad esempio gli oggetti in primo piano, quelli sullo sfondo, il terreno, ecc...<br>Un TileLevel &eacute; formato da un array di posizioni, che indica la posizione di ogni tile nel livello e da una lista di ID, che rappresenta la texture da applicare su ogni tile del livello.<br>La TileMap dato l'elevato numero di oggetti che contiene viene renderizzata invocando il metodo <samp>glDrawElementsInstanced()</samp> delle OpenGL, che permette di renderizzare tutte le Tile della mappa con una sola draw call.</p><h4>Input</h4><p>La classe Input &eacute; di tipo Singleton, quindi il programma, dopo aver instanziato gl ioggetti di gioco, ne chiede il riferimento mediante il metodo <samp>Input.getInput()</samp>.<br>La gestione degli input viene effettuata tramite un Observer multi thread.</p><img src="../static/projects/Tile Engine Java/descriptionImages/umlJavaObserverMultiThread.jpg"  style="max-width:100%;"><p>La classe Input estende la classe Java Observable e implementa l'interfaccia Runnable.<br>Ogni 30ms viene invocato il metodo <samp>checkInput()</samp> che si occupa di controllare gli eventi avvenuti dalla chiamata precedente.<br>Input contiene una lista di KeyEvents, che rappresenta la lista degli eventi avvenuti tra una chiamata e l'altra, e un array di keyState, che rappresentalo stato dei tasti di cui ci interessano gli eventi (W, A, S, D, ESC).<br>Ad ogni chiamata di checkInput se &eacute; avvenuto un evento vengono notificati gli Observer (Player e Game), a cui viene passata la lista degli eventi, che verra poi azzerata.<br>Il Player e il Game implementano entrambi l'interfaccia Observer e il suo metodo <samp>update()</samp>, che al suo interno contiene la gestione degli eventi avvenuti, in base all'oggetto su cui &eacute; chiamato, sul Player viene modificato l'attributo di tipo <samp>Vector2f</samp>, che contiene la direzione del Player, in base alla pressione dei tasti W, A, S e D, mentre, sul Game viene controllata la pressione del tasto ESC, che comporta la chiusura dell'applicazione.</p><p>Dopo che gli oggetti Player e Game sono stati passati come Observer al Subject input, viene instanziato il Renderer, che crea la matrice di proiezione ortogonale.<br>Il Renderer contiene il metodo <samp>render(List&lt;Renderable&gt;)</samp> a cui viene passata la lista di Renderable, su cui chiama i metodi per il rendering.</p><div style="border-style: solid;padding: 10px;border-width: thin; max-width:100%; overflow:scroll;"><pre><code>public void render(List<Entity> renderables){    for (Entity renderable : renderables) {        renderable.update();        renderable.bindProjectionMatrix(projectionMatrix);        renderable.render();    }}</code></pre></div><h2>Main Loop</h2><p>Il Main Loop viene eseguito finche non si ha una richiesta di chiusura da parte dell'Input, premendo il tasto ESC, o del DisplayManager, clickando sulla x della finestra.<br>Per prima cosa viene effettuato il clear del display, poi, per ogni oggetto Renderable, viene chiamato il metodo <samp>handleInput()</samp> che modifica il comportamento dell'oggetto in base agli input registrati in precedenza.</p><h4>Gestione degli stati</h4><p>Lo stato degli oggetti di gioco viene gestito mediante il pattern State.</p><img src="../static/projects/Tile Engine Java/descriptionImages/umlJavaState.jpg"  style="max-width:100%;"><p>Durante la creazione di un oggetto gli viene assegnato uno stato iniziale, poi ad ogni frame, se c'&eacute; stata una modifica da parte degli input, lo stato viene cambiato.<br>Il pattern gestisce anche le animazioni dell'oggetto, al momento dell'ingresso in uno stato l'animazione viene avviata, poi ad ogni chiamata del metodo <samp>update()</samp> viene aggiornata in base al tempo trascorso dal frame precedente, e, infine, quando si esce dallo stato corrente, l'animazione viene fermata.</p><p>Una volta terminata la gestione degli stati, viene chiamato il metodo <samp>render(List&lt;Renderable&gt;)</samp> del Renderer e gli viene passata la lista dei Renderable.<br>Finito il rendering il metodo <samp>updateDisplay()</samp> del DisplayManager viene invocato per aggiornare la schermata corrente.<br>Infine viene eseguito il controllo sulle richieste per la chiusura del programma.</p><h2>Chiusura</h2><p>Se, durante il Main Loop, si ha una richiesta di chiusura, viene invocato il metodo <samp>closeGame()</samp>, questo, termina il thread Input, invoca il metodo <samp>closeDisplay()</samp> del DisplayManager ed esce dal programma.</p>